#!/usr/bin/env python3

"""
This program is part of MoaT.
Its job is simply to extract values from a YAML-formatted config file.
"""

from Cfg import Cfg
import sys
import os
import re

### copied from port.h
PO_OFF=0
PO_ON=1
PO_Z=2
PO_PULLUP=3

PFLG_ALERT=  (1<<2)
PFLG_ALT  =  (1<<3)
PFLG_ALT2 =  (1<<4)

### copied from adc.h
ADC_VBG=1
ADC_VGND=2
ADC_VTEMP=3
ADC_ALT=(1<<3)
ADC_REF=(1<<4)
ADC_ALERT=(1<<5)

### copied from pwm.h
PWM_ALERT=(1<<0)
PWM_FORCE=(1<<1)

follow=True
xstr = re.compile("^x([0-9a-fA-F]{2}){1,}$")

def main(f,*kk):
    s = Cfg(f)
    if kk:
        mode = ""
        for k in kk:
            if mode == "":
                if k[0] == '.':
                    if k == '.devs':
                        print(" ".join(sorted(k for k in s.subtree("devices") if not k.startswith('_'))))
                    if k == ".follow":
                        s.follow = True
                    elif k == ".nofollow":
                        s.follow = False
                    else:
                        mode = k[1:]
                else:
                    did=[]
                    ks = k.split('.')
                    res = s.subtree(*ks)
                    if isinstance(res,dict):
                        print(" ".join("{}={}".format(a,v) for a,v in s.keyval(*ks)))
                    elif isinstance(res,(list,tuple)):
                        print(" ".join(str(x) for x in res))
                    elif isinstance(res,str) and xstr.match(res):
                        print(res[1:])
                    else:
                        try:
                            f = float(res)
                        except Exception:
                            print(res)
                        else:
                            g = int(f)
                            if float(g) == f:
                                print(g)
                            else:
                                print(f)
            elif mode == "hdr":
                with open("device/"+k+"/_port.h","w") as f:
                    print("""\
/*
 * This file is auto-generated. It contains the list of input/output ports for
 * the device "{}".
 *
 * Do not edit. Talk to 'moat.cfg' instead.
 */
    """.format(k), file=f)
                    for i in range(1, int(s.subtree('devices',k,'types','port'))+1):
                        v = s.subtree('devices',k,'port',str(i))
                        flg=0
                        p=0
                        assert len(v)>=2 and len(v) <=6
                        for vv in v:
                            if vv >= 'A' and vv <= 'Z':
                                assert not p
                                p |= (ord(vv)-ord("A"))<<3
                            elif vv >= '0' and vv <= '7':
                                assert not (p&0x7)
                                p |= ord(vv)-ord("0")
                            elif vv == "^": flg|=PO_ON
                            elif vv == "_": flg|=PO_OFF
                            elif vv == "+": flg|=PO_PULLUP
                            elif vv == "~": flg|=PO_Z       ## high-impedance
                            elif vv == "/": flg|=PFLG_ALT   ## alt switch 1: low vs. pullup
                            elif vv == "!": flg|=PFLG_ALT2  ## alt switch 2: lw vs. Z
                            elif vv == "*": flg|=PFLG_ALERT ## participate in alerting
                            else: assert 0,vv
                        print('{'+"{},{}".format(p,flg)+'},',file=f)

                with open("device/"+k+"/_adc.h","w") as f:
                    print("""\
/*
 * This file is auto-generated. It contains the list of analog inputs for
 * the device "{}".
 *
 * Do not edit. Talk to 'moat.cfg' instead.
 */
    """.format(k), file=f)
                    for i in range(1, int(s.subtree('devices',k,'types','adc'))+1):
                        v = s.subtree('devices',k,'adc',str(i))
                        flg=0
                        p=0
                        if type(v) == int: v = str(v)
                        assert len(v)>=1 and len(v) <=3
                        for vv in v:
                            if vv >= '0' and vv <= '7':
                                assert not (flg&0xF)
                                flg |= ord(vv)-ord("0")
                                p=1
                            elif vv == "R":
                                assert not p
                                flg|=ADC_ALT|ADC_VBG
                                p=1
                            elif vv == "G":
                                assert not p
                                flg|=ADC_ALT|ADC_VGND
                                p=1
                            elif vv == "T":
                                assert not p
                                flg|=ADC_ALT|ADC_VTEMP
                                p=1
                            elif vv == "-": flg|=ADC_REF   ## use ref voltage as max
                            elif vv == "*": flg|=ADC_ALERT ## participate in alerting
                            else: assert 0,vv
                        assert p
                        print('{'+"{},".format(flg)+'},',file=f)

                with open("device/"+k+"/_pwm.h","w") as f:
                    print("""\
/*
 * This file is auto-generated. It contains the list of ports to do PWM with
 * on the device "{}".
 *
 * Do not edit. Talk to 'moat.cfg' instead.
 */
    """.format(k), file=f)
                    seen = set()
                    for i in range(1, int(s.subtree('devices',k,'types','pwm'))+1):
                        v = s.subtree('devices',k,'pwm',str(i))
                        flg = 0
                        port = 0
                        p = 0
                        if isinstance(v,int):
                            port = v
                        else:
                            assert len(v)>=1 and len(v) <=3
                            for vv in v:
                                if vv >= '0' and vv <= '9':
                                    assert not flg;
                                    port = 10*port+(flg-'0');
                                    p = 1
                                elif vv == "*": flg|=PWM_ALERT ## participate in alerting
                                elif vv == "!": flg|=PWM_FORCE ## immediately switch
                                else: assert 0,vv
                            assert p
                        if v in seen:
                            print("Warning: PWM %d is known"%v,file=sys.stderr)
                            continue
                        seen.add(v)
                        print('{'+"{},{}".format(port,flg)+'},',file=f)

                with open("device/"+k+"/_count.h","w") as f:
                    print("""\
/*
 * This file is auto-generated. It contains the list of ports to count
 * transitions of, on the device "{}".
 *
 * Do not edit. Talk to 'moat.cfg' instead.
 */
    """.format(k), file=f)
                    seen = set()
                    for i in range(1, int(s.subtree('devices',k,'types','count'))+1):
                        v = s.subtree('devices',k,'count',str(i))
                        flg=0
                        p=0
                        if isinstance(v,str):
                            if v.endswith('*'):
                                flg |= 1
                                v = v[:-1]
                            v = int(v)
                        if v in seen:
                            print("Warning: PWM %d is known"%v,file=sys.stderr)
                            continue
                        seen.add(v)
                        print('{'+"{},{}".format(v,flg)+'},',file=f)

                i = 0
                typecode = {}
                typecodes = []
                for a in s.subtree('codes','types'):
                    if a.startswith('_'):
                        a = a[1:]
                    else:
                        typecode[a]=i
                    typecodes.append(a)
                    i += 1

                max_t = 2 # config, alert
                typecount = [0]*i
                for a,v in s.keyval('devices',k,'types'):
                    v = int(v)
                    if v and max_t < typecode[a]:
                        max_t = typecode[a]
                    typecount[typecode[a]] = v

                with open("device/"+k+"/_nums.h","w") as f:
                    print("""\
/*
 * This file is auto-generated. It contains the number of devices.
 *
 * Do not edit. Talk to 'moat.cfg' instead.
 */
    """.format(k), file=f)
                    typecount[0] = len(s.subtree('codes','blocks'))
                    typecount[1] = max_t
                    for i in range(max_t+1):
                        a = typecodes[i]
                        print("{}, // {}".format(typecount[i],a), file=f)

                with open("device/"+k+"/_def.h","w") as f:
                    print("""\
/*
 * This file is auto-generated. It contains the device codes.
 *
 * Do not edit. Talk to 'moat.cfg' instead.
 */
    """.format(k), file=f)
                    for i in range(max_t+1):
                        a = typecodes[i]
                        print("TC_DEFINE({})".format(a), file=f)


                with open("device/"+k+"/dev_config.h","w") as f:
                    print("""\
#ifndef device_{}_config_h
#define device_{}_config_h

/*
 * This file is auto-generated. It contains a mix of global and local
 * definitions because I am lazy.
 *
 * Do not edit. Talk to 'moat.cfg' instead.
 */
    """.format(k,k), file=f)

                    i = 0
                    print("typedef enum _ConfigID {", file=f)
                    for a in s.subtree('codes','blocks'):
                        if a.startswith('_'):
                            a=a[1:]
                        else:
                            typecode[a]=i
                        print("    CfgID_{} = {},".format(a,i), file=f)
                        i += 1
                    print("""    CfgID_MAX
#define CFG_MAX CfgID_MAX
} ConfigID;""", file=f)

                    for a,v in s.keyval('devices',k,'defs'):
                        try:
                            v = int(v)
                        except ValueError:
                            v = '"{}"'.format(v.replace('\\','\\\\').replace('"','\\"'))
                        else:
                            if not v:
                                continue

                        print("#define {} {}".format(a.upper(),v), file=f)

                    ow = s.subtree('devices',k,'defs','is_onewire')
                    if ow:
                        print("#define HAVE_ONEWIRE 1", file=f)
                        print("#define ONEWIRE_"+ow.upper(), file=f)

                    for a,v in s.keyval('devices',k,'types'):
                        if a == "config":
                            v = len(s.subtree('codes','blocks'))
                        elif a == "alert":
                            #v = len(s.subtree('codes','types'))
                            v = max_t+1 # ignore codes above this
                        else:
                            v = int(v)
                        print("#define TC_{} {}".format(a.upper(),typecode[a]), file=f)
                        if v > 0:
                            print("#define N_{} {}".format(a.upper(),v), file=f)
                    print("""\
#define TC_MAX {}

#endif /* device_{}_config_h */
    """.format(max_t+1,k,k), file=f)

            elif mode == "type":
                print(" ".join("{} {}".format(a,v) for a,v in s.keyval('devices',k,'types')))
            elif mode == "cdefs":
                types = dict((a,int(v)) for a,v in s.keyval('devices',k,'types') if int(v) > 0)
                maxtype = max(())
                print(" ".join("-D{}=\"{}\"".format(a.upper(),str(v).replace('"','\"')) for a,v in s.keyval('devices',k,'defs')) + " " + " ".join("-DN_{}={}".format(a.upper(),v) for a,v in s.keyval('devices',k,'types') if int(v) > 0))
            elif mode == "cfiles":
                files = ['main.c','jmp.S']
                if s.subtree('devices',k,'defs','is_bootloader'):
                    files.append('owadr.o')
                else:
                    files.append('dev_data.c')
                    files.append('config.o')
                if s.subtree('devices',k,'defs','have_uart'):
                    files.append('uart.c')
                if s.subtree('devices',k,'defs','have_timer'):
                    files.append('timer.c')
                ow = s.subtree('devices',k,'defs','is_onewire')
                if not ow: pass
                else:
                    files.append(ow+'.c')
                    files.append('onewire.c')
                for f in s.subtree('devices',k,'code'):
                    files.append(f+'.c')
                for f in s.subtree('devices',k,'types'):
                    if f[0] == '_': continue
                    if os.path.exists(f+'.c'):
                        files.append(f+'.c')

                if ow == "moat":
                    for f in s.subtree('codes','types'):
                        if f.startswith('_'):
                            f = f[1:]
                        f = 'moat_'+f
                        if os.path.exists(f+'.c'):
                            files.append(f+'.c')

                print(" ".join(files))
            else:
                print("Unknown mode:",mode, file=sys.stderr)
                sys.exit(2)
    else:
        import pprint
        pprint.pprint(s.data)

if __name__ == "__main__":
    if len(sys.argv) < 2:
        print("Usage: {} file [type] [key…]".format(sys.argv[0]), file=sys.stderr)
        sys.exit(2)
    main(*sys.argv[1:])
